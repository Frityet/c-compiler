local ffi = require("ffi")

local cdef = [[
/* generated by autogen_ffi */
typedef struct CallInfo CallInfo;
typedef struct lua_State lua_State;
struct lua_Debug {
  int event;
  const char * name;
  const char * namewhat;
  const char * what;
  const char * source;
  size_t srclen;
  int currentline;
  int linedefined;
  int lastlinedefined;
  unsigned char nups;
  unsigned char nparams;
  char isvararg;
  char istailcall;
  unsigned short ftransfer;
  unsigned short ntransfer;
  char * short_src;
  struct CallInfo * i_ci;
};

typedef void * (*lua_Alloc)(void * ud, void * ptr, size_t osize, size_t nsize);
typedef int (*lua_CFunction)(lua_State * L);
typedef struct lua_Debug lua_Debug;
typedef void (*lua_Hook)(lua_State * L, lua_Debug * ar);
typedef long long lua_Integer;
typedef intptr_t lua_KContext;
typedef int (*lua_KFunction)(lua_State * L, int status, lua_KContext ctx);
typedef double lua_Number;
typedef const char * (*lua_Reader)(lua_State * L, void * ud, size_t * sz);
typedef unsigned long long lua_Unsigned;
typedef void (*lua_WarnFunction)(void * ud, const char * msg, int tocont);
typedef int (*lua_Writer)(lua_State * L, const void * p, size_t sz, void * ud);
int lua_absindex(lua_State * L, int idx);
void lua_arith(lua_State * L, int op);
lua_CFunction lua_atpanic(lua_State * L, lua_CFunction panicf);
void lua_callk(lua_State * L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k);
int lua_checkstack(lua_State * L, int n);
void lua_close(lua_State * L);
void lua_closeslot(lua_State * L, int idx);
int lua_closethread(lua_State * L, lua_State * from);
int lua_compare(lua_State * L, int idx1, int idx2, int op);
void lua_concat(lua_State * L, int n);
void lua_copy(lua_State * L, int fromidx, int toidx);
void lua_createtable(lua_State * L, int narr, int nrec);
int lua_dump(lua_State * L, lua_Writer writer, void * data, int strip);
int lua_error(lua_State * L);
int lua_gc(lua_State * L, int what, ...);
lua_Alloc lua_getallocf(lua_State * L, void * * ud);
int lua_getfield(lua_State * L, int idx, const char * k);
int lua_getglobal(lua_State * L, const char * name);
lua_Hook lua_gethook(lua_State * L);
int lua_gethookcount(lua_State * L);
int lua_gethookmask(lua_State * L);
int lua_geti(lua_State * L, int idx, lua_Integer n);
int lua_getinfo(lua_State * L, const char * what, lua_Debug * ar);
int lua_getiuservalue(lua_State * L, int idx, int n);
const char * lua_getlocal(lua_State * L, const lua_Debug * ar, int n);
int lua_getmetatable(lua_State * L, int objindex);
int lua_getstack(lua_State * L, int level, lua_Debug * ar);
int lua_gettable(lua_State * L, int idx);
int lua_gettop(lua_State * L);
const char * lua_getupvalue(lua_State * L, int funcindex, int n);
int lua_iscfunction(lua_State * L, int idx);
int lua_isinteger(lua_State * L, int idx);
int lua_isnumber(lua_State * L, int idx);
int lua_isstring(lua_State * L, int idx);
int lua_isuserdata(lua_State * L, int idx);
int lua_isyieldable(lua_State * L);
void lua_len(lua_State * L, int idx);
int lua_load(lua_State * L, lua_Reader reader, void * dt, const char * chunkname, const char * mode);
lua_State * lua_newstate(lua_Alloc f, void * ud);
lua_State * lua_newthread(lua_State * L);
void * lua_newuserdatauv(lua_State * L, size_t sz, int nuvalue);
int lua_next(lua_State * L, int idx);
int lua_pcallk(lua_State * L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k);
void lua_pushboolean(lua_State * L, int b);
void lua_pushcclosure(lua_State * L, lua_CFunction fn, int n);
const char * lua_pushfstring(lua_State * L, const char * fmt, ...);
void lua_pushinteger(lua_State * L, lua_Integer n);
void lua_pushlightuserdata(lua_State * L, void * p);
const char * lua_pushlstring(lua_State * L, const char * s, size_t len);
void lua_pushnil(lua_State * L);
void lua_pushnumber(lua_State * L, lua_Number n);
const char * lua_pushstring(lua_State * L, const char * s);
int lua_pushthread(lua_State * L);
void lua_pushvalue(lua_State * L, int idx);
const char * lua_pushvfstring(lua_State * L, const char * fmt, va_list argp);
int lua_rawequal(lua_State * L, int idx1, int idx2);
int lua_rawget(lua_State * L, int idx);
int lua_rawgeti(lua_State * L, int idx, lua_Integer n);
int lua_rawgetp(lua_State * L, int idx, const void * p);
lua_Unsigned lua_rawlen(lua_State * L, int idx);
void lua_rawset(lua_State * L, int idx);
void lua_rawseti(lua_State * L, int idx, lua_Integer n);
void lua_rawsetp(lua_State * L, int idx, const void * p);
int lua_resetthread(lua_State * L);
int lua_resume(lua_State * L, lua_State * from, int narg, int * nres);
void lua_rotate(lua_State * L, int idx, int n);
void lua_setallocf(lua_State * L, lua_Alloc f, void * ud);
int lua_setcstacklimit(lua_State * L, int limit);
void lua_setfield(lua_State * L, int idx, const char * k);
void lua_setglobal(lua_State * L, const char * name);
void lua_sethook(lua_State * L, lua_Hook func, int mask, int count);
void lua_seti(lua_State * L, int idx, lua_Integer n);
int lua_setiuservalue(lua_State * L, int idx, int n);
const char * lua_setlocal(lua_State * L, const lua_Debug * ar, int n);
int lua_setmetatable(lua_State * L, int objindex);
void lua_settable(lua_State * L, int idx);
void lua_settop(lua_State * L, int idx);
const char * lua_setupvalue(lua_State * L, int funcindex, int n);
void lua_setwarnf(lua_State * L, lua_WarnFunction f, void * ud);
int lua_status(lua_State * L);
size_t lua_stringtonumber(lua_State * L, const char * s);
int lua_toboolean(lua_State * L, int idx);
lua_CFunction lua_tocfunction(lua_State * L, int idx);
void lua_toclose(lua_State * L, int idx);
lua_Integer lua_tointegerx(lua_State * L, int idx, int * isnum);
const char * lua_tolstring(lua_State * L, int idx, size_t * len);
lua_Number lua_tonumberx(lua_State * L, int idx, int * isnum);
const void * lua_topointer(lua_State * L, int idx);
lua_State * lua_tothread(lua_State * L, int idx);
void * lua_touserdata(lua_State * L, int idx);
int lua_type(lua_State * L, int idx);
const char * lua_typename(lua_State * L, int tp);
void * lua_upvalueid(lua_State * L, int fidx, int n);
void lua_upvaluejoin(lua_State * L, int fidx1, int n1, int fidx2, int n2);
lua_Number lua_version(lua_State * L);
void lua_warning(lua_State * L, const char * msg, int tocont);
void lua_xmove(lua_State * from, lua_State * to, int n);
int lua_yieldk(lua_State * L, int nresults, lua_KContext ctx, lua_KFunction k);
]]

ffi.cdef(cdef)

local record lua
   record Debug is ffi.CData where ffi.istype("struct lua_Debug", self)

      event: integer

      name: ffi.String

      namewhat: ffi.String

      what: ffi.String

      source: ffi.String

      srclen: size_t

      currentline: integer

      linedefined: integer

      lastlinedefined: integer

      nups: integer

      nparams: integer

      isvararg: integer

      istailcall: integer

      ftransfer: integer

      ntransfer: integer

      short_src: ffi.Array<integer>

      i_ci: ffi.Pointer<CallInfo>

   end

   record CallInfo is ffi.CData where ffi.istype("struct CallInfo", self) end

   record State is ffi.CData where ffi.istype("struct lua_State", self) end

   record va_list is ffi.CData where ffi.istype("va_list", self) end

   record Hook is ffi.CData where ffi.istype("lua_Hook", self) end

   record WarnFunction is ffi.CData where ffi.istype("lua_WarnFunction", self) end

   record Number is ffi.CFloat where ffi.istype("lua_Number", self) end

   record Integer is ffi.CInteger where ffi.istype("lua_Integer", self) end

   record Writer is ffi.CData where ffi.istype("lua_Writer", self) end

   record KFunction is ffi.CData where ffi.istype("lua_KFunction", self) end

   record size_t is ffi.CData where ffi.istype("size_t", self) end

   record KContext is ffi.CData where ffi.istype("lua_KContext", self) end

   record intptr_t is ffi.CData where ffi.istype("intptr_t", self) end

   record Alloc is ffi.CData where ffi.istype("lua_Alloc", self) end

   record Unsigned is ffi.CInteger where ffi.istype("lua_Unsigned", self) end

   record Reader is ffi.CData where ffi.istype("lua_Reader", self) end

   record CFunction is ffi.CData where ffi.istype("lua_CFunction", self) end

   pushstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, s: ffi.String): ffi.String>
   pushvfstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fmt: ffi.String, argp: va_list): ffi.String>
   pushfstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fmt: ffi.String, ...: any): ffi.String>
   pushcclosure: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fn: CFunction, n: integer): nil>
   pushboolean: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, b: integer): nil>
   pushlightuserdata: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, p: ffi.Pointer<nil>): nil>
   pushthread: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   getglobal: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, name: ffi.String): integer>
   gettable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   getfield: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, k: ffi.String): integer>
   geti: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: Integer): integer>
   rawget: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   rawgeti: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: Integer): integer>
   rawgetp: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, p: ffi.Pointer<nil>): integer>
   createtable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, narr: integer, nrec: integer): nil>
   newuserdatauv: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, sz: size_t, nuvalue: integer): ffi.Pointer<nil>>
   getmetatable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, objindex: integer): integer>
   getiuservalue: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: integer): integer>
   setglobal: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, name: ffi.String): nil>
   settable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   setfield: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, k: ffi.String): nil>
   seti: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: Integer): nil>
   rawset: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   rawseti: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: Integer): nil>
   rawsetp: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, p: ffi.Pointer<nil>): nil>
   setmetatable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, objindex: integer): integer>
   newstate: ffi.Function<function(ffi.Function<nil>, f: Alloc, ud: ffi.Pointer<nil>): ffi.Pointer<State>>
   callk: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, nargs: integer, nresults: integer, ctx: ffi.CData, k: KFunction): nil>
   close: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): nil>
   newthread: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): ffi.Pointer<State>>
   closethread: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, from: ffi.Pointer<State>): integer>
   getinfo: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, what: ffi.String, ar: ffi.Pointer<Debug>): integer>
   resetthread: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   getlocal: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, ar: ffi.Pointer<Debug>, n: integer): ffi.String>
   setlocal: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, ar: ffi.Pointer<Debug>, n: integer): ffi.String>
   atpanic: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, panicf: CFunction): CFunction>
   version: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): Number>
   absindex: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   gettop: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   settop: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   pushvalue: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   rotate: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: integer): nil>
   copy: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fromidx: integer, toidx: integer): nil>
   pcallk: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, nargs: integer, nresults: integer, errfunc: integer, ctx: ffi.CData, k: KFunction): integer>
   checkstack: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, n: integer): integer>
   xmove: ffi.Function<function(ffi.Function<nil>, from: ffi.Pointer<State>, to: ffi.Pointer<State>, n: integer): nil>
   concat: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, n: integer): nil>
   len: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   isnumber: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   isstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   iscfunction: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   isinteger: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   isuserdata: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   type: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   typename: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, tp: integer): ffi.String>
   tonumberx: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, isnum: ffi.Pointer<integer>): Number>
   setcstacklimit: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, limit: integer): integer>
   getstack: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, level: integer, ar: ffi.Pointer<Debug>): integer>
   getupvalue: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, funcindex: integer, n: integer): ffi.String>
   tointegerx: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, isnum: ffi.Pointer<integer>): Integer>
   toboolean: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   tolstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, len: ffi.Pointer<size_t>): ffi.String>
   setupvalue: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, funcindex: integer, n: integer): ffi.String>
   rawlen: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): Unsigned>
   tocfunction: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): CFunction>
   upvaluejoin: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fidx1: integer, n1: integer, fidx2: integer, n2: integer): nil>
   touserdata: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): ffi.Pointer<nil>>
   tothread: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): ffi.Pointer<State>>
   topointer: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): ffi.Pointer<nil>>
   upvalueid: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, fidx: integer, n: integer): ffi.Pointer<nil>>
   sethook: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, func: Hook, mask: integer, count: integer): nil>
   status: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   isyieldable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   gethook: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): Hook>
   gethookmask: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   gethookcount: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   setwarnf: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, f: WarnFunction, ud: ffi.Pointer<nil>): nil>
   warning: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, msg: ffi.String, tocont: integer): nil>
   closeslot: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   toclose: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): nil>
   setallocf: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, f: Alloc, ud: ffi.Pointer<nil>): nil>
   getallocf: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, ud: ffi.Pointer<ffi.Pointer<nil>>): Alloc>
   stringtonumber: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, s: ffi.String): size_t>
   setiuservalue: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer, n: integer): integer>
   error: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): integer>
   arith: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, op: integer): nil>
   dump: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, writer: Writer, data: ffi.Pointer<nil>, strip: integer): integer>
   resume: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, from: ffi.Pointer<State>, narg: integer, nres: ffi.Pointer<integer>): integer>
   yieldk: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, nresults: integer, ctx: ffi.CData, k: KFunction): integer>
   rawequal: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx1: integer, idx2: integer): integer>
   gc: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, what: integer, ...: any): integer>
   load: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, reader: Reader, dt: ffi.Pointer<nil>, chunkname: ffi.String, mode: ffi.String): integer>
   compare: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx1: integer, idx2: integer, op: integer): integer>
   next: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, idx: integer): integer>
   pushnil: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>): nil>
   pushnumber: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, n: Number): nil>
   pushinteger: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, n: Integer): nil>
   pushlstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<State>, s: ffi.String, len: size_t): ffi.String>
end

local STRIP_PREFIX = "lua_"

local raw = ffi.load("lua")

local lib = setmetatable({
   cdef = cdef
}, {
   __index = function(self: {string:any}, key: string): any
      local ckey = STRIP_PREFIX .. key
      local ok, val = pcall(function(): any return raw[ckey] end)
      if ok and not val is nil then
         rawset(self, key, val)
         return val
      end
      local v = raw[key]
      rawset(self, key, v)
      return v
   end,

   __newindex = function(self: {string:any}, key: string, value: any): nil
      local ckey = STRIP_PREFIX .. key
      local ok = pcall(function(): nil raw[ckey] = value end)
      if ok then return end
      raw[key] = value
   end,
})
         

return lib as lua
