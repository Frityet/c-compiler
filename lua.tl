local ffi = require("ffi")

local cdef = [[
/* generated by autogen_ffi */
typedef struct CallInfo CallInfo;
typedef struct lua_State lua_State;
struct lua_Debug {
  int event;
  const char * name;
  const char * namewhat;
  const char * what;
  const char * source;
  size_t srclen;
  int currentline;
  int linedefined;
  int lastlinedefined;
  unsigned char nups;
  unsigned char nparams;
  char isvararg;
  char istailcall;
  unsigned short ftransfer;
  unsigned short ntransfer;
  char * short_src;
  struct CallInfo * i_ci;
};

typedef void * (*lua_Alloc)(void * ud, void * ptr, size_t osize, size_t nsize);
typedef int (*lua_CFunction)(lua_State * L);
typedef struct lua_Debug lua_Debug;
typedef void (*lua_Hook)(lua_State * L, lua_Debug * ar);
typedef long long lua_Integer;
typedef intptr_t lua_KContext;
typedef int (*lua_KFunction)(lua_State * L, int status, lua_KContext ctx);
typedef double lua_Number;
typedef const char * (*lua_Reader)(lua_State * L, void * ud, size_t * sz);
typedef unsigned long long lua_Unsigned;
typedef void (*lua_WarnFunction)(void * ud, const char * msg, int tocont);
typedef int (*lua_Writer)(lua_State * L, const void * p, size_t sz, void * ud);
int lua_absindex(lua_State * L, int idx);
void lua_arith(lua_State * L, int op);
lua_CFunction lua_atpanic(lua_State * L, lua_CFunction panicf);
void lua_callk(lua_State * L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k);
int lua_checkstack(lua_State * L, int n);
void lua_close(lua_State * L);
void lua_closeslot(lua_State * L, int idx);
int lua_closethread(lua_State * L, lua_State * from);
int lua_compare(lua_State * L, int idx1, int idx2, int op);
void lua_concat(lua_State * L, int n);
void lua_copy(lua_State * L, int fromidx, int toidx);
void lua_createtable(lua_State * L, int narr, int nrec);
int lua_dump(lua_State * L, lua_Writer writer, void * data, int strip);
int lua_error(lua_State * L);
int lua_gc(lua_State * L, int what, ...);
lua_Alloc lua_getallocf(lua_State * L, void * * ud);
int lua_getfield(lua_State * L, int idx, const char * k);
int lua_getglobal(lua_State * L, const char * name);
lua_Hook lua_gethook(lua_State * L);
int lua_gethookcount(lua_State * L);
int lua_gethookmask(lua_State * L);
int lua_geti(lua_State * L, int idx, lua_Integer n);
int lua_getinfo(lua_State * L, const char * what, lua_Debug * ar);
int lua_getiuservalue(lua_State * L, int idx, int n);
int lua_getmetatable(lua_State * L, int objindex);
int lua_getstack(lua_State * L, int level, lua_Debug * ar);
int lua_gettable(lua_State * L, int idx);
int lua_gettop(lua_State * L);
int lua_iscfunction(lua_State * L, int idx);
int lua_isinteger(lua_State * L, int idx);
int lua_isnumber(lua_State * L, int idx);
int lua_isstring(lua_State * L, int idx);
int lua_isuserdata(lua_State * L, int idx);
int lua_isyieldable(lua_State * L);
void lua_len(lua_State * L, int idx);
int lua_load(lua_State * L, lua_Reader reader, void * dt, const char * chunkname, const char * mode);
int lua_next(lua_State * L, int idx);
int lua_pcallk(lua_State * L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k);
void lua_pushboolean(lua_State * L, int b);
void lua_pushcclosure(lua_State * L, lua_CFunction fn, int n);
void lua_pushinteger(lua_State * L, lua_Integer n);
void lua_pushlightuserdata(lua_State * L, void * p);
void lua_pushnil(lua_State * L);
void lua_pushnumber(lua_State * L, lua_Number n);
int lua_pushthread(lua_State * L);
void lua_pushvalue(lua_State * L, int idx);
int lua_rawequal(lua_State * L, int idx1, int idx2);
int lua_rawget(lua_State * L, int idx);
int lua_rawgeti(lua_State * L, int idx, lua_Integer n);
int lua_rawgetp(lua_State * L, int idx, const void * p);
lua_Unsigned lua_rawlen(lua_State * L, int idx);
void lua_rawset(lua_State * L, int idx);
void lua_rawseti(lua_State * L, int idx, lua_Integer n);
void lua_rawsetp(lua_State * L, int idx, const void * p);
int lua_resetthread(lua_State * L);
int lua_resume(lua_State * L, lua_State * from, int narg, int * nres);
void lua_rotate(lua_State * L, int idx, int n);
void lua_setallocf(lua_State * L, lua_Alloc f, void * ud);
int lua_setcstacklimit(lua_State * L, int limit);
void lua_setfield(lua_State * L, int idx, const char * k);
void lua_setglobal(lua_State * L, const char * name);
void lua_sethook(lua_State * L, lua_Hook func, int mask, int count);
void lua_seti(lua_State * L, int idx, lua_Integer n);
int lua_setiuservalue(lua_State * L, int idx, int n);
int lua_setmetatable(lua_State * L, int objindex);
void lua_settable(lua_State * L, int idx);
void lua_settop(lua_State * L, int idx);
void lua_setwarnf(lua_State * L, lua_WarnFunction f, void * ud);
int lua_status(lua_State * L);
size_t lua_stringtonumber(lua_State * L, const char * s);
int lua_toboolean(lua_State * L, int idx);
lua_CFunction lua_tocfunction(lua_State * L, int idx);
void lua_toclose(lua_State * L, int idx);
lua_Integer lua_tointegerx(lua_State * L, int idx, int * isnum);
lua_Number lua_tonumberx(lua_State * L, int idx, int * isnum);
int lua_type(lua_State * L, int idx);
void lua_upvaluejoin(lua_State * L, int fidx1, int n1, int fidx2, int n2);
lua_Number lua_version(lua_State * L);
void lua_warning(lua_State * L, const char * msg, int tocont);
void lua_xmove(lua_State * from, lua_State * to, int n);
int lua_yieldk(lua_State * L, int nresults, lua_KContext ctx, lua_KFunction k);
]]

ffi.cdef(cdef)

local record lua
   record Debug is ffi.CData where ffi.istype("struct lua_Debug", self)

      event: integer

      name: ffi.Pointer<integer>

      namewhat: ffi.Pointer<integer>

      what: ffi.Pointer<integer>

      source: ffi.Pointer<integer>

      srclen: size_t

      currentline: integer

      linedefined: integer

      lastlinedefined: integer

      nups: integer

      nparams: integer

      isvararg: integer

      istailcall: integer

      ftransfer: integer

      ntransfer: integer

      short_src: ffi.Array<integer>

      i_ci: ffi.Pointer<CallInfo>

   end

   record CallInfo is ffi.CData where ffi.istype("struct CallInfo", self) end

   record State is ffi.CData where ffi.istype("struct lua_State", self) end

   record va_list is ffi.CData where ffi.istype("va_list", self) end

   record Integer is ffi.CData where ffi.istype("lua_Integer", self) end

   record Writer is ffi.CData where ffi.istype("lua_Writer", self) end

   record KFunction is ffi.CData where ffi.istype("lua_KFunction", self) end

   record Hook is ffi.CData where ffi.istype("lua_Hook", self) end

   record KContext is ffi.CData where ffi.istype("lua_KContext", self) end

   record Unsigned is ffi.CData where ffi.istype("lua_Unsigned", self) end

   record Reader is ffi.CData where ffi.istype("lua_Reader", self) end

   record CFunction is ffi.CData where ffi.istype("lua_CFunction", self) end

   record intptr_t is ffi.CData where ffi.istype("intptr_t", self) end

   record Alloc is ffi.CData where ffi.istype("lua_Alloc", self) end

   record size_t is ffi.CData where ffi.istype("size_t", self) end

   record WarnFunction is ffi.CData where ffi.istype("lua_WarnFunction", self) end

   record Number is ffi.CData where ffi.istype("lua_Number", self) end

   tointegerx: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, isnum: ffi.Pointer<integer>): Integer>
   toboolean: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   rawlen: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): Unsigned>
   tocfunction: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): CFunction>
   arith: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, op: integer): nil>
   rawequal: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx1: integer, idx2: integer): integer>
   resume: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, from: ffi.Pointer<State>, narg: integer, nres: ffi.Pointer<integer>): integer>
   compare: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx1: integer, idx2: integer, op: integer): integer>
   status: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   isyieldable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   pushinteger: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, n: Integer): nil>
   getinfo: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, what: ffi.Pointer<integer>, ar: ffi.Pointer<Debug>): integer>
   setwarnf: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, f: WarnFunction, ud: ffi.Pointer<nil>): nil>
   warning: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, msg: ffi.Pointer<integer>, tocont: integer): nil>
   upvaluejoin: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, fidx1: integer, n1: integer, fidx2: integer, n2: integer): nil>
   pushcclosure: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, fn: CFunction, n: integer): nil>
   pushboolean: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, b: integer): nil>
   gc: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, what: integer, ...: any): integer>
   gethook: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): Hook>
   pushthread: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   next: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   getglobal: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, name: ffi.Pointer<integer>): integer>
   len: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   gettable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   getfield: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, k: ffi.Pointer<integer>): integer>
   setallocf: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, f: Alloc, ud: ffi.Pointer<nil>): nil>
   geti: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: Integer): integer>
   rawget: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   rawgeti: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: Integer): integer>
   rawgetp: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, p: ffi.Pointer<nil>): integer>
   createtable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, narr: integer, nrec: integer): nil>
   getmetatable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, objindex: integer): integer>
   getiuservalue: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: integer): integer>
   setglobal: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, name: ffi.Pointer<integer>): nil>
   settable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   setfield: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, k: ffi.Pointer<integer>): nil>
   seti: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: Integer): nil>
   rawset: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   rawseti: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: Integer): nil>
   rawsetp: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, p: ffi.Pointer<nil>): nil>
   setmetatable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, objindex: integer): integer>
   setiuservalue: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: integer): integer>
   callk: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, nargs: integer, nresults: integer, ctx: ffi.CData, k: KFunction): nil>
   close: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): nil>
   setcstacklimit: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, limit: integer): integer>
   closethread: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, from: ffi.Pointer<State>): integer>
   gethookcount: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   gethookmask: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   resetthread: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   sethook: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, func: Hook, mask: integer, count: integer): nil>
   getstack: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, level: integer, ar: ffi.Pointer<Debug>): integer>
   closeslot: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   atpanic: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, panicf: CFunction): CFunction>
   toclose: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   version: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): Number>
   getallocf: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, ud: ffi.Pointer<ffi.Pointer<nil>>): Alloc>
   absindex: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   gettop: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   settop: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   pushvalue: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): nil>
   rotate: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, n: integer): nil>
   copy: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, fromidx: integer, toidx: integer): nil>
   stringtonumber: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, s: ffi.Pointer<integer>): size_t>
   pcallk: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, nargs: integer, nresults: integer, errfunc: integer, ctx: ffi.CData, k: KFunction): integer>
   checkstack: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, n: integer): integer>
   xmove: ffi.Function<function(ffi.NilFunc, from: ffi.Pointer<State>, to: ffi.Pointer<State>, n: integer): nil>
   concat: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, n: integer): nil>
   error: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): integer>
   pushnumber: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, n: Number): nil>
   isnumber: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   isstring: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   iscfunction: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   isinteger: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   load: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, reader: Reader, dt: ffi.Pointer<nil>, chunkname: ffi.Pointer<integer>, mode: ffi.Pointer<integer>): integer>
   type: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   pushnil: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>): nil>
   pushlightuserdata: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, p: ffi.Pointer<nil>): nil>
   isuserdata: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer): integer>
   tonumberx: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, idx: integer, isnum: ffi.Pointer<integer>): Number>
   dump: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, writer: Writer, data: ffi.Pointer<nil>, strip: integer): integer>
   yieldk: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<State>, nresults: integer, ctx: ffi.CData, k: KFunction): integer>
end

local STRIP_PREFIX = "lua_"

local lua: lua = ffi.load("lua") as lua

getmetatable(lua).__index = function(self: {string:any}, key: string): any
   local ckey = STRIP_PREFIX .. key
   local val = rawget(self, ckey)
   if not val is nil then return val end
   val = rawget(self, key)
   if not val is nil then return val end
   error("attempt to access undefined member '" .. key .. "'")
end

return lua
