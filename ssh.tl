local ffi = require("ffi")

local cdef = [[
/* generated by autogen_ffi */
typedef struct ssh_channel_struct ssh_channel_struct;
typedef struct ssh_message_struct ssh_message_struct;
typedef struct timeval timeval;
typedef struct ssh_pcap_file_struct ssh_pcap_file_struct;
typedef struct ssh_knownhosts_entry ssh_knownhosts_entry;
typedef struct ssh_key_struct ssh_key_struct;
typedef struct ssh_connector_struct ssh_connector_struct;
typedef struct ssh_scp_struct ssh_scp_struct;
typedef struct ssh_event_struct ssh_event_struct;
typedef struct ssh_agent_struct ssh_agent_struct;
typedef struct ssh_counter_struct ssh_counter_struct;
typedef struct ssh_string_struct ssh_string_struct;
typedef struct ssh_session_struct ssh_session_struct;
typedef struct ssh_buffer_struct ssh_buffer_struct;
enum ssh_publickey_hash_type {
  SSH_PUBLICKEY_HASH_SHA1,
  SSH_PUBLICKEY_HASH_MD5,
  SSH_PUBLICKEY_HASH_SHA256
};

enum ssh_known_hosts_e {
  SSH_KNOWN_HOSTS_ERROR,
  SSH_KNOWN_HOSTS_NOT_FOUND,
  SSH_KNOWN_HOSTS_UNKNOWN = 0,
  SSH_KNOWN_HOSTS_OK,
  SSH_KNOWN_HOSTS_CHANGED,
  SSH_KNOWN_HOSTS_OTHER
};

enum ssh_control_master_options_e {
  SSH_CONTROL_MASTER_NO,
  SSH_CONTROL_MASTER_AUTO,
  SSH_CONTROL_MASTER_YES,
  SSH_CONTROL_MASTER_ASK,
  SSH_CONTROL_MASTER_AUTOASK
};

enum ssh_global_requests_e {
  SSH_GLOBAL_REQUEST_UNKNOWN = 0,
  SSH_GLOBAL_REQUEST_TCPIP_FORWARD,
  SSH_GLOBAL_REQUEST_CANCEL_TCPIP_FORWARD,
  SSH_GLOBAL_REQUEST_KEEPALIVE,
  SSH_GLOBAL_REQUEST_NO_MORE_SESSIONS
};

enum ssh_requests_e {
  SSH_REQUEST_AUTH = 1,
  SSH_REQUEST_CHANNEL_OPEN,
  SSH_REQUEST_CHANNEL,
  SSH_REQUEST_SERVICE,
  SSH_REQUEST_GLOBAL
};

enum ssh_options_e {
  SSH_OPTIONS_HOST,
  SSH_OPTIONS_PORT,
  SSH_OPTIONS_PORT_STR,
  SSH_OPTIONS_FD,
  SSH_OPTIONS_USER,
  SSH_OPTIONS_SSH_DIR,
  SSH_OPTIONS_IDENTITY,
  SSH_OPTIONS_ADD_IDENTITY,
  SSH_OPTIONS_KNOWNHOSTS,
  SSH_OPTIONS_TIMEOUT,
  SSH_OPTIONS_TIMEOUT_USEC,
  SSH_OPTIONS_SSH1,
  SSH_OPTIONS_SSH2,
  SSH_OPTIONS_LOG_VERBOSITY,
  SSH_OPTIONS_LOG_VERBOSITY_STR,
  SSH_OPTIONS_CIPHERS_C_S,
  SSH_OPTIONS_CIPHERS_S_C,
  SSH_OPTIONS_COMPRESSION_C_S,
  SSH_OPTIONS_COMPRESSION_S_C,
  SSH_OPTIONS_PROXYCOMMAND,
  SSH_OPTIONS_BINDADDR,
  SSH_OPTIONS_STRICTHOSTKEYCHECK,
  SSH_OPTIONS_COMPRESSION,
  SSH_OPTIONS_COMPRESSION_LEVEL,
  SSH_OPTIONS_KEY_EXCHANGE,
  SSH_OPTIONS_HOSTKEYS,
  SSH_OPTIONS_GSSAPI_SERVER_IDENTITY,
  SSH_OPTIONS_GSSAPI_CLIENT_IDENTITY,
  SSH_OPTIONS_GSSAPI_DELEGATE_CREDENTIALS,
  SSH_OPTIONS_HMAC_C_S,
  SSH_OPTIONS_HMAC_S_C,
  SSH_OPTIONS_PASSWORD_AUTH,
  SSH_OPTIONS_PUBKEY_AUTH,
  SSH_OPTIONS_KBDINT_AUTH,
  SSH_OPTIONS_GSSAPI_AUTH,
  SSH_OPTIONS_GLOBAL_KNOWNHOSTS,
  SSH_OPTIONS_NODELAY,
  SSH_OPTIONS_PUBLICKEY_ACCEPTED_TYPES,
  SSH_OPTIONS_PROCESS_CONFIG,
  SSH_OPTIONS_REKEY_DATA,
  SSH_OPTIONS_REKEY_TIME,
  SSH_OPTIONS_RSA_MIN_SIZE,
  SSH_OPTIONS_IDENTITY_AGENT,
  SSH_OPTIONS_IDENTITIES_ONLY,
  SSH_OPTIONS_CONTROL_MASTER,
  SSH_OPTIONS_CONTROL_PATH,
  SSH_OPTIONS_CERTIFICATE,
  SSH_OPTIONS_PROXYJUMP,
  SSH_OPTIONS_PROXYJUMP_CB_LIST_APPEND
};

enum ssh_publickey_state_e {
  SSH_PUBLICKEY_STATE_ERROR,
  SSH_PUBLICKEY_STATE_NONE = 0,
  SSH_PUBLICKEY_STATE_VALID = 1,
  SSH_PUBLICKEY_STATE_WRONG = 2
};

enum ssh_auth_e {
  SSH_AUTH_SUCCESS = 0,
  SSH_AUTH_DENIED,
  SSH_AUTH_PARTIAL,
  SSH_AUTH_INFO,
  SSH_AUTH_AGAIN,
  SSH_AUTH_ERROR
};

enum ssh_channel_type_e {
  SSH_CHANNEL_UNKNOWN = 0,
  SSH_CHANNEL_SESSION,
  SSH_CHANNEL_DIRECT_TCPIP,
  SSH_CHANNEL_FORWARDED_TCPIP,
  SSH_CHANNEL_X11,
  SSH_CHANNEL_AUTH_AGENT
};

enum ssh_scp_request_types {
  SSH_SCP_REQUEST_NEWDIR = 1,
  SSH_SCP_REQUEST_NEWFILE,
  SSH_SCP_REQUEST_EOF,
  SSH_SCP_REQUEST_ENDDIR,
  SSH_SCP_REQUEST_WARNING
};

enum ssh_keycmp_e {
  SSH_KEY_CMP_PUBLIC = 0,
  SSH_KEY_CMP_PRIVATE = 1,
  SSH_KEY_CMP_CERTIFICATE = 2
};

enum ssh_error_types_e {
  SSH_NO_ERROR = 0,
  SSH_REQUEST_DENIED,
  SSH_FATAL,
  SSH_EINTR
};

enum ssh_server_known_e {
  SSH_SERVER_ERROR,
  SSH_SERVER_NOT_KNOWN = 0,
  SSH_SERVER_KNOWN_OK,
  SSH_SERVER_KNOWN_CHANGED,
  SSH_SERVER_FOUND_OTHER,
  SSH_SERVER_FILE_NOT_FOUND
};

enum ssh_channel_requests_e {
  SSH_CHANNEL_REQUEST_UNKNOWN = 0,
  SSH_CHANNEL_REQUEST_PTY,
  SSH_CHANNEL_REQUEST_EXEC,
  SSH_CHANNEL_REQUEST_SHELL,
  SSH_CHANNEL_REQUEST_ENV,
  SSH_CHANNEL_REQUEST_SUBSYSTEM,
  SSH_CHANNEL_REQUEST_WINDOW_CHANGE,
  SSH_CHANNEL_REQUEST_X11
};

enum ssh_file_format_e {
  SSH_FILE_FORMAT_DEFAULT = 0,
  SSH_FILE_FORMAT_OPENSSH,
  SSH_FILE_FORMAT_PEM
};

enum ssh_kex_types_e {
  SSH_KEX = 0,
  SSH_HOSTKEYS,
  SSH_CRYPT_C_S,
  SSH_CRYPT_S_C,
  SSH_MAC_C_S,
  SSH_MAC_S_C,
  SSH_COMP_C_S,
  SSH_COMP_S_C,
  SSH_LANG_C_S,
  SSH_LANG_S_C
};

enum ssh_connector_flags_e {
  SSH_CONNECTOR_STDOUT = 1,
  SSH_CONNECTOR_STDINOUT = 1,
  SSH_CONNECTOR_STDERR = 2,
  SSH_CONNECTOR_BOTH = 3
};

enum ssh_keytypes_e {
  SSH_KEYTYPE_UNKNOWN = 0,
  SSH_KEYTYPE_DSS = 1,
  SSH_KEYTYPE_RSA,
  SSH_KEYTYPE_RSA1,
  SSH_KEYTYPE_ECDSA,
  SSH_KEYTYPE_ED25519,
  SSH_KEYTYPE_DSS_CERT01,
  SSH_KEYTYPE_RSA_CERT01,
  SSH_KEYTYPE_ECDSA_P256,
  SSH_KEYTYPE_ECDSA_P384,
  SSH_KEYTYPE_ECDSA_P521,
  SSH_KEYTYPE_ECDSA_P256_CERT01,
  SSH_KEYTYPE_ECDSA_P384_CERT01,
  SSH_KEYTYPE_ECDSA_P521_CERT01,
  SSH_KEYTYPE_ED25519_CERT01,
  SSH_KEYTYPE_SK_ECDSA,
  SSH_KEYTYPE_SK_ECDSA_CERT01,
  SSH_KEYTYPE_SK_ED25519,
  SSH_KEYTYPE_SK_ED25519_CERT01
};

struct ssh_counter_struct {
  uint64_t in_bytes;
  uint64_t out_bytes;
  uint64_t in_packets;
  uint64_t out_packets;
};

struct ssh_knownhosts_entry {
  char * hostname;
  char * unparsed;
  ssh_key publickey;
  char * comment;
};

typedef int socket_t;
typedef struct ssh_agent_struct * ssh_agent;
typedef int (*ssh_auth_callback)(const char * prompt, char * buf, size_t len, int echo, int verify, void * userdata);
typedef struct ssh_buffer_struct * ssh_buffer;
typedef struct ssh_channel_struct * ssh_channel;
typedef struct ssh_connector_struct * ssh_connector;
typedef struct ssh_counter_struct * ssh_counter;
typedef struct ssh_event_struct * ssh_event;
typedef int (*ssh_event_callback)(socket_t fd, int revents, void * userdata);
typedef void * ssh_gssapi_creds;
typedef struct ssh_key_struct * ssh_key;
typedef struct ssh_message_struct * ssh_message;
typedef struct ssh_pcap_file_struct * ssh_pcap_file;
typedef struct ssh_scp_struct * ssh_scp;
typedef struct ssh_session_struct * ssh_session;
typedef struct ssh_string_struct * ssh_string;
int __attribute__(int * visibility(int));
int __format__(int __printf__, int 3, int 4);
int ssh_blocking_flush(ssh_session session, int timeout);
int ssh_buffer_add_data(ssh_buffer buffer, const void * data, uint32_t len);
void ssh_buffer_free(ssh_buffer buffer);
void * ssh_buffer_get(ssh_buffer buffer);
uint32_t ssh_buffer_get_data(ssh_buffer buffer, void * data, uint32_t requestedlen);
uint32_t ssh_buffer_get_len(ssh_buffer buffer);
ssh_buffer ssh_buffer_new(void);
int ssh_buffer_reinit(ssh_buffer buffer);
ssh_channel ssh_channel_accept_forward(ssh_session session, int timeout_ms, int * destination_port);
ssh_channel ssh_channel_accept_x11(ssh_channel channel, int timeout_ms);
int ssh_channel_cancel_forward(ssh_session session, const char * address, int port);
int ssh_channel_change_pty_size(ssh_channel channel, int cols, int rows);
int ssh_channel_close(ssh_channel channel);
void ssh_channel_free(ssh_channel channel);
int ssh_channel_get_exit_state(ssh_channel channel, uint32_t * pexit_code, char * * pexit_signal, int * pcore_dumped);
int ssh_channel_listen_forward(ssh_session session, const char * address, int port, int * bound_port);
int ssh_channel_select(ssh_channel * readchans, ssh_channel * writechans, ssh_channel * exceptchans, struct timeval * timeout);
int ssh_event_add_connector(ssh_event event, ssh_connector connector);
int ssh_event_add_fd(ssh_event event, socket_t fd, short events, ssh_event_callback cb, void * userdata);
int ssh_event_add_session(ssh_event event, ssh_session session);
int ssh_event_dopoll(ssh_event event, int timeout);
void ssh_event_free(ssh_event event);
ssh_event ssh_event_new(void);
int ssh_event_remove_connector(ssh_event event, ssh_connector connector);
int ssh_event_remove_fd(ssh_event event, socket_t fd);
int ssh_event_remove_session(ssh_event event, ssh_session session);
ssh_channel ssh_forward_accept(ssh_session session, int timeout_ms);
int ssh_forward_listen(ssh_session session, const char * address, int port, int * bound_port);
void ssh_free(ssh_session session);
const char * ssh_get_cipher_in(ssh_session session);
const char * ssh_get_cipher_out(ssh_session session);
const char * ssh_get_clientbanner(ssh_session session);
const char * ssh_get_disconnect_message(ssh_session session);
const char * ssh_get_error(void * error);
int ssh_get_error_code(void * error);
socket_t ssh_get_fd(ssh_session session);
char * ssh_get_hexa(const unsigned char * what, size_t len);
const char * ssh_get_hmac_in(ssh_session session);
const char * ssh_get_hmac_out(ssh_session session);
char * ssh_get_issue_banner(ssh_session session);
const char * ssh_get_kex_algo(ssh_session session);
int ssh_get_log_level(void);
void * ssh_get_log_userdata(void);
int ssh_get_openssh_version(ssh_session session);
int ssh_get_poll_flags(ssh_session session);
int ssh_get_random(void * where, int len, int strong);
int ssh_get_server_publickey(ssh_session session, ssh_key * key);
const char * ssh_get_serverbanner(ssh_session session);
int ssh_get_status(ssh_session session);
int ssh_get_version(ssh_session session);
int ssh_getpass(const char * prompt, char * buf, size_t len, int echo, int verify);
void ssh_gssapi_set_creds(ssh_session session, const ssh_gssapi_creds creds);
int ssh_init(void);
int ssh_is_blocking(ssh_session session);
int ssh_is_connected(ssh_session session);
int ssh_is_server_known(ssh_session session);
ssh_key ssh_key_dup(const ssh_key key);
void ssh_key_free(ssh_key key);
int ssh_key_is_private(const ssh_key k);
int ssh_key_is_public(const ssh_key k);
ssh_key ssh_key_new(void);
int ssh_known_hosts_parse_line(const char * host, const char * line, struct ssh_knownhosts_entry * * entry);
void ssh_knownhosts_entry_free(struct ssh_knownhosts_entry * entry);
ssh_channel ssh_message_channel_request_open_reply_accept(ssh_message msg);
int ssh_message_channel_request_open_reply_accept_channel(ssh_message msg, ssh_channel chan);
int ssh_message_channel_request_reply_success(ssh_message msg);
void ssh_message_free(ssh_message msg);
ssh_message ssh_message_get(ssh_session session);
int ssh_message_subtype(ssh_message msg);
int ssh_message_type(ssh_message msg);
int ssh_mkdir(const char * pathname, mode_t mode);
ssh_session ssh_new(void);
int ssh_options_copy(ssh_session src, ssh_session * dest);
int ssh_options_get_port(ssh_session session, int * port_target);
int ssh_options_getopt(ssh_session session, int * argcptr, char * * argv);
int ssh_options_parse_config(ssh_session session, const char * filename);
int ssh_pcap_file_close(ssh_pcap_file pcap);
void ssh_pcap_file_free(ssh_pcap_file pcap);
ssh_pcap_file ssh_pcap_file_new(void);
int ssh_pcap_file_open(ssh_pcap_file pcap, const char * filename);
int ssh_pki_copy_cert_to_privkey(const ssh_key cert_key, ssh_key privkey);
int ssh_pki_export_privkey_base64(const ssh_key privkey, const char * passphrase, ssh_auth_callback auth_fn, void * auth_data, char * * b64_key);
int ssh_pki_export_privkey_file(const ssh_key privkey, const char * passphrase, ssh_auth_callback auth_fn, void * auth_data, const char * filename);
int ssh_pki_export_privkey_to_pubkey(const ssh_key privkey, ssh_key * pkey);
int ssh_pki_export_pubkey_base64(const ssh_key key, char * * b64_key);
int ssh_pki_export_pubkey_file(const ssh_key key, const char * filename);
int ssh_pki_import_cert_file(const char * filename, ssh_key * pkey);
int ssh_pki_import_privkey_base64(const char * b64_key, const char * passphrase, ssh_auth_callback auth_fn, void * auth_data, ssh_key * pkey);
int ssh_pki_import_privkey_file(const char * filename, const char * passphrase, ssh_auth_callback auth_fn, void * auth_data, ssh_key * pkey);
int ssh_pki_import_pubkey_file(const char * filename, ssh_key * pkey);
const char * ssh_pki_key_ecdsa_name(const ssh_key key);
int ssh_request_no_more_sessions(ssh_session session);
int ssh_scp_close(ssh_scp scp);
void ssh_scp_free(ssh_scp scp);
int ssh_scp_leave_directory(ssh_scp scp);
int ssh_scp_pull_request(ssh_scp scp);
int ssh_scp_push_file(ssh_scp scp, const char * filename, size_t size, int perms);
int ssh_scp_read(ssh_scp scp, void * buffer, size_t size);
int ssh_scp_request_get_permissions(ssh_scp scp);
uint64_t ssh_scp_request_get_size64(ssh_scp scp);
int ssh_scp_write(ssh_scp scp, const void * buffer, size_t len);
int ssh_select(ssh_channel * channels, ssh_channel * outchannels, socket_t maxfd, fd_set * readfds, struct timeval * timeout);
int ssh_send_debug(ssh_session session, const char * message, int always_display);
int ssh_send_ignore(ssh_session session, const char * data);
int ssh_service_request(ssh_session session, const char * service);
int ssh_session_export_known_hosts_entry(ssh_session session, char * * pentry_string);
int ssh_session_set_disconnect_message(ssh_session session, const char * message);
int ssh_session_update_known_hosts(ssh_session session);
int ssh_set_agent_channel(ssh_session session, ssh_channel channel);
int ssh_set_agent_socket(ssh_session session, socket_t fd);
void ssh_set_blocking(ssh_session session, int blocking);
void ssh_set_counters(ssh_session session, ssh_counter scounter, ssh_counter rcounter);
void ssh_set_fd_except(ssh_session session);
void ssh_set_fd_toread(ssh_session session);
void ssh_set_fd_towrite(ssh_session session);
int ssh_set_log_level(int level);
int ssh_set_log_userdata(void * data);
int ssh_set_pcap_file(ssh_session session, ssh_pcap_file pcapfile);
void ssh_silent_disconnect(ssh_session session);
void ssh_string_burn(ssh_string str);
ssh_string ssh_string_copy(ssh_string str);
void * ssh_string_data(ssh_string str);
int ssh_string_fill(ssh_string str, const void * data, size_t len);
void ssh_string_free(ssh_string str);
void ssh_string_free_char(char * s);
ssh_string ssh_string_from_char(const char * what);
const char * ssh_string_get_char(ssh_string str);
size_t ssh_string_len(ssh_string str);
ssh_string ssh_string_new(size_t size);
char * ssh_string_to_char(ssh_string str);
int ssh_userauth_agent(ssh_session session, const char * username);
int ssh_userauth_gssapi(ssh_session session);
int ssh_userauth_kbdint(ssh_session session, const char * user, const char * submethods);
const char * ssh_userauth_kbdint_getanswer(ssh_session session, int i);
const char * ssh_userauth_kbdint_getinstruction(ssh_session session);
const char * ssh_userauth_kbdint_getname(ssh_session session);
int ssh_userauth_kbdint_getnanswers(ssh_session session);
int ssh_userauth_kbdint_getnprompts(ssh_session session);
const char * ssh_userauth_kbdint_getprompt(ssh_session session, int i, char * echo);
int ssh_userauth_kbdint_setanswer(ssh_session session, int i, const char * answer);
int ssh_userauth_list(ssh_session session, const char * username);
int ssh_userauth_none(ssh_session session, const char * username);
int ssh_userauth_password(ssh_session session, const char * username, const char * password);
int ssh_userauth_publickey(ssh_session session, const char * username, const ssh_key privkey);
int ssh_userauth_publickey_auto(ssh_session session, const char * username, const char * passphrase);
int ssh_userauth_publickey_auto_get_current_identity(ssh_session session, char * * value);
int ssh_userauth_try_publickey(ssh_session session, const char * username, const ssh_key pubkey);
const char * ssh_version(int req_version);
void ssh_vlog(int verbosity, const char * function, const char * format, va_list * va);
int ssh_write_knownhost(ssh_session session);
int visibility(int);
]]

ffi.cdef(cdef)

local record ssh
   record counter_struct is ffi.CData where ffi.istype("struct ssh_counter_struct", self)

      in_bytes: uint64_t

      out_bytes: uint64_t

      in_packets: uint64_t

      out_packets: uint64_t

   end

   record knownhosts_entry is ffi.CData where ffi.istype("struct ssh_knownhosts_entry", self)

      hostname: ffi.Pointer<integer>

      unparsed: ffi.Pointer<integer>

      publickey: key

      comment: ffi.Pointer<integer>

   end

   record channel_struct is ffi.CData where ffi.istype("struct ssh_channel_struct", self) end

   record message_struct is ffi.CData where ffi.istype("struct ssh_message_struct", self) end

   record timeval is ffi.CData where ffi.istype("struct timeval", self) end

   record pcap_file_struct is ffi.CData where ffi.istype("struct ssh_pcap_file_struct", self) end

   record key_struct is ffi.CData where ffi.istype("struct ssh_key_struct", self) end

   record connector_struct is ffi.CData where ffi.istype("struct ssh_connector_struct", self) end

   record scp_struct is ffi.CData where ffi.istype("struct ssh_scp_struct", self) end

   record event_struct is ffi.CData where ffi.istype("struct ssh_event_struct", self) end

   record agent_struct is ffi.CData where ffi.istype("struct ssh_agent_struct", self) end

   record string_struct is ffi.CData where ffi.istype("struct ssh_string_struct", self) end

   record session_struct is ffi.CData where ffi.istype("struct ssh_session_struct", self) end

   record buffer_struct is ffi.CData where ffi.istype("struct ssh_buffer_struct", self) end

   type publickey_hash_type = integer
   type known_hosts_e = integer
   type control_master_options_e = integer
   type global_requests_e = integer
   type requests_e = integer
   type options_e = integer
   type publickey_state_e = integer
   type auth_e = integer
   type channel_type_e = integer
   type scp_request_types = integer
   type keycmp_e = integer
   type error_types_e = integer
   type server_known_e = integer
   type channel_requests_e = integer
   type file_format_e = integer
   type kex_types_e = integer
   type connector_flags_e = integer
   type keytypes_e = integer
   record buffer is ffi.CData where ffi.istype("ssh_buffer", self) end

   record channel is ffi.CData where ffi.istype("ssh_channel", self) end

   record va_list is ffi.CData where ffi.istype("va_list", self) end

   record message is ffi.CData where ffi.istype("ssh_message", self) end

   record pcap_file is ffi.CData where ffi.istype("ssh_pcap_file", self) end

   record key is ffi.CData where ffi.istype("ssh_key", self) end

   record scp is ffi.CData where ffi.istype("ssh_scp", self) end

   record session is ffi.CData where ffi.istype("ssh_session", self) end

   record string is ffi.CData where ffi.istype("ssh_string", self) end

   record event is ffi.CData where ffi.istype("ssh_event", self) end

   record connector is ffi.CData where ffi.istype("ssh_connector", self) end

   record gssapi_creds is ffi.CData where ffi.istype("ssh_gssapi_creds", self) end

   record socket_t is ffi.CInteger where ffi.istype("socket_t", self) end

   record uint32_t is ffi.CData where ffi.istype("uint32_t", self) end

   record auth_callback is ffi.CData where ffi.istype("ssh_auth_callback", self) end

   record counter is ffi.CData where ffi.istype("ssh_counter", self) end

   record event_callback is ffi.CData where ffi.istype("ssh_event_callback", self) end

   record fd_set is ffi.CData where ffi.istype("fd_set", self) end

   record mode_t is ffi.CData where ffi.istype("mode_t", self) end

   record size_t is ffi.CData where ffi.istype("size_t", self) end

   record agent is ffi.CData where ffi.istype("ssh_agent", self) end

   record uint64_t is ffi.CData where ffi.istype("uint64_t", self) end

   options_copy: ffi.Function<function(ffi.Function<nil>, src: session, dest: ffi.Pointer<session>): integer>
   options_getopt: ffi.Function<function(ffi.Function<nil>, session: session, argcptr: ffi.Pointer<integer>, argv: ffi.Pointer<ffi.Pointer<integer>>): integer>
   channel_free: ffi.Function<function(ffi.Function<nil>, channel: channel): nil>
   options_get_port: ffi.Function<function(ffi.Function<nil>, session: session, port_target: ffi.Pointer<integer>): integer>
   pcap_file_close: ffi.Function<function(ffi.Function<nil>, pcap: pcap_file): integer>
   pcap_file_free: ffi.Function<function(ffi.Function<nil>, pcap: pcap_file): nil>
   pcap_file_new: ffi.Function<function(ffi.Function<nil>, nil): pcap_file>
   pcap_file_open: ffi.Function<function(ffi.Function<nil>, pcap: pcap_file, filename: ffi.String): integer>
   channel_get_exit_state: ffi.Function<function(ffi.Function<nil>, channel: channel, pexit_code: ffi.Pointer<uint32_t>, pexit_signal: ffi.Pointer<ffi.Pointer<integer>>, pcore_dumped: ffi.Pointer<integer>): integer>
   key_new: ffi.Function<function(ffi.Function<nil>, nil): key>
   key_free: ffi.Function<function(ffi.Function<nil>, key: key): nil>
   key_is_public: ffi.Function<function(ffi.Function<nil>, k: key): integer>
   key_is_private: ffi.Function<function(ffi.Function<nil>, k: key): integer>
   key_dup: ffi.Function<function(ffi.Function<nil>, key: key): key>
   pki_import_privkey_base64: ffi.Function<function(ffi.Function<nil>, b64_key: ffi.String, passphrase: ffi.String, auth_fn: auth_callback, auth_data: ffi.Pointer<nil>, pkey: ffi.Pointer<key>): integer>
   pki_export_privkey_base64: ffi.Function<function(ffi.Function<nil>, privkey: key, passphrase: ffi.String, auth_fn: auth_callback, auth_data: ffi.Pointer<nil>, b64_key: ffi.Pointer<ffi.Pointer<integer>>): integer>
   pki_import_privkey_file: ffi.Function<function(ffi.Function<nil>, filename: ffi.String, passphrase: ffi.String, auth_fn: auth_callback, auth_data: ffi.Pointer<nil>, pkey: ffi.Pointer<key>): integer>
   pki_export_privkey_file: ffi.Function<function(ffi.Function<nil>, privkey: key, passphrase: ffi.String, auth_fn: auth_callback, auth_data: ffi.Pointer<nil>, filename: ffi.String): integer>
   pki_copy_cert_to_privkey: ffi.Function<function(ffi.Function<nil>, cert_key: key, privkey: key): integer>
   pki_import_pubkey_file: ffi.Function<function(ffi.Function<nil>, filename: ffi.String, pkey: ffi.Pointer<key>): integer>
   pki_import_cert_file: ffi.Function<function(ffi.Function<nil>, filename: ffi.String, pkey: ffi.Pointer<key>): integer>
   pki_export_privkey_to_pubkey: ffi.Function<function(ffi.Function<nil>, privkey: key, pkey: ffi.Pointer<key>): integer>
   pki_export_pubkey_base64: ffi.Function<function(ffi.Function<nil>, key: key, b64_key: ffi.Pointer<ffi.Pointer<integer>>): integer>
   pki_export_pubkey_file: ffi.Function<function(ffi.Function<nil>, key: key, filename: ffi.String): integer>
   pki_key_ecdsa_name: ffi.Function<function(ffi.Function<nil>, key: key): ffi.String>
   send_ignore: ffi.Function<function(ffi.Function<nil>, session: session, data: ffi.String): integer>
   send_debug: ffi.Function<function(ffi.Function<nil>, session: session, message: ffi.String, always_display: integer): integer>
   gssapi_set_creds: ffi.Function<function(ffi.Function<nil>, session: session, creds: gssapi_creds): nil>
   select: ffi.Function<function(ffi.Function<nil>, channels: ffi.Pointer<channel>, outchannels: ffi.Pointer<channel>, maxfd: socket_t, readfds: ffi.Pointer<fd_set>, timeout: ffi.Pointer<timeval>): integer>
   service_request: ffi.Function<function(ffi.Function<nil>, session: session, service: ffi.String): integer>
   set_agent_channel: ffi.Function<function(ffi.Function<nil>, session: session, channel: channel): integer>
   set_agent_socket: ffi.Function<function(ffi.Function<nil>, session: session, fd: socket_t): integer>
   set_blocking: ffi.Function<function(ffi.Function<nil>, session: session, blocking: integer): nil>
   set_counters: ffi.Function<function(ffi.Function<nil>, session: session, scounter: counter, rcounter: counter): nil>
   set_fd_except: ffi.Function<function(ffi.Function<nil>, session: session): nil>
   set_fd_toread: ffi.Function<function(ffi.Function<nil>, session: session): nil>
   set_fd_towrite: ffi.Function<function(ffi.Function<nil>, session: session): nil>
   silent_disconnect: ffi.Function<function(ffi.Function<nil>, session: session): nil>
   set_pcap_file: ffi.Function<function(ffi.Function<nil>, session: session, pcapfile: pcap_file): integer>
   userauth_none: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String): integer>
   userauth_list: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String): integer>
   userauth_try_publickey: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String, pubkey: key): integer>
   userauth_publickey: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String, privkey: key): integer>
   channel_accept_forward: ffi.Function<function(ffi.Function<nil>, session: session, timeout_ms: integer, destination_port: ffi.Pointer<integer>): channel>
   channel_cancel_forward: ffi.Function<function(ffi.Function<nil>, session: session, address: ffi.String, port: integer): integer>
   __attribute__: ffi.Function<function(ffi.Function<nil>, visibility: ffi.Pointer<ffi.Function<function(ffi.Function<nil>, integer): integer>>): integer>
   channel_listen_forward: ffi.Function<function(ffi.Function<nil>, session: session, address: ffi.String, port: integer, bound_port: ffi.Pointer<integer>): integer>
   session_set_disconnect_message: ffi.Function<function(ffi.Function<nil>, session: session, message: ffi.String): integer>
   buffer_get_len: ffi.Function<function(ffi.Function<nil>, buffer: buffer): uint32_t>
   userauth_agent: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String): integer>
   get_disconnect_message: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   userauth_publickey_auto_get_current_identity: ffi.Function<function(ffi.Function<nil>, session: session, value: ffi.Pointer<ffi.Pointer<integer>>): integer>
   buffer_get: ffi.Function<function(ffi.Function<nil>, buffer: buffer): ffi.Pointer<nil>>
   get_serverbanner: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   get_error_code: ffi.Function<function(ffi.Function<nil>, error: ffi.Pointer<nil>): integer>
   userauth_publickey_auto: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String, passphrase: ffi.String): integer>
   userauth_password: ffi.Function<function(ffi.Function<nil>, session: session, username: ffi.String, password: ffi.String): integer>
   get_cipher_out: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   userauth_kbdint: ffi.Function<function(ffi.Function<nil>, session: session, user: ffi.String, submethods: ffi.String): integer>
   get_openssh_version: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   request_no_more_sessions: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   userauth_kbdint_getinstruction: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   userauth_kbdint_getname: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   userauth_kbdint_getnprompts: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   userauth_kbdint_getprompt: ffi.Function<function(ffi.Function<nil>, session: session, i: integer, echo: ffi.Pointer<integer>): ffi.String>
   scp_leave_directory: ffi.Function<function(ffi.Function<nil>, scp: scp): integer>
   userauth_kbdint_getnanswers: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   visibility: ffi.Function<function(ffi.Function<nil>, integer): integer>
   scp_pull_request: ffi.Function<function(ffi.Function<nil>, scp: scp): integer>
   get_hmac_in: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   buffer_free: ffi.Function<function(ffi.Function<nil>, buffer: buffer): nil>
   userauth_gssapi: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   scp_push_file: ffi.Function<function(ffi.Function<nil>, scp: scp, filename: ffi.String, size: size_t, perms: integer): integer>
   forward_accept: ffi.Function<function(ffi.Function<nil>, session: session, timeout_ms: integer): channel>
   string_burn: ffi.Function<function(ffi.Function<nil>, str: string): nil>
   forward_listen: ffi.Function<function(ffi.Function<nil>, session: session, address: ffi.String, port: integer, bound_port: ffi.Pointer<integer>): integer>
   string_data: ffi.Function<function(ffi.Function<nil>, str: string): ffi.Pointer<nil>>
   write_knownhost: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   buffer_new: ffi.Function<function(ffi.Function<nil>, nil): buffer>
   is_server_known: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   string_from_char: ffi.Function<function(ffi.Function<nil>, what: ffi.String): string>
   scp_request_get_permissions: ffi.Function<function(ffi.Function<nil>, scp: scp): integer>
   channel_select: ffi.Function<function(ffi.Function<nil>, readchans: ffi.Pointer<channel>, writechans: ffi.Pointer<channel>, exceptchans: ffi.Pointer<channel>, timeout: ffi.Pointer<timeval>): integer>
   scp_request_get_size64: ffi.Function<function(ffi.Function<nil>, scp: scp): uint64_t>
   string_get_char: ffi.Function<function(ffi.Function<nil>, str: string): ffi.String>
   scp_write: ffi.Function<function(ffi.Function<nil>, scp: scp, buffer: ffi.Pointer<nil>, len: size_t): integer>
   get_random: ffi.Function<function(ffi.Function<nil>, where: ffi.Pointer<nil>, len: integer, strong: integer): integer>
   string_free_char: ffi.Function<function(ffi.Function<nil>, s: ffi.Pointer<integer>): nil>
   get_version: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   get_status: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   get_poll_flags: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   init: ffi.Function<function(ffi.Function<nil>, nil): integer>
   is_blocking: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   is_connected: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   knownhosts_entry_free: ffi.Function<function(ffi.Function<nil>, entry: ffi.Pointer<knownhosts_entry>): nil>
   scp_free: ffi.Function<function(ffi.Function<nil>, scp: scp): nil>
   event_add_fd: ffi.Function<function(ffi.Function<nil>, event: event, fd: socket_t, events: integer, cb: event_callback, userdata: ffi.Pointer<nil>): integer>
   get_clientbanner: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   buffer_reinit: ffi.Function<function(ffi.Function<nil>, buffer: buffer): integer>
   buffer_add_data: ffi.Function<function(ffi.Function<nil>, buffer: buffer, data: ffi.Pointer<nil>, len: uint32_t): integer>
   buffer_get_data: ffi.Function<function(ffi.Function<nil>, buffer: buffer, data: ffi.Pointer<nil>, requestedlen: uint32_t): uint32_t>
   event_add_session: ffi.Function<function(ffi.Function<nil>, event: event, session: session): integer>
   event_add_connector: ffi.Function<function(ffi.Function<nil>, event: event, connector: connector): integer>
   event_dopoll: ffi.Function<function(ffi.Function<nil>, event: event, timeout: integer): integer>
   known_hosts_parse_line: ffi.Function<function(ffi.Function<nil>, host: ffi.String, line: ffi.String, entry: ffi.Pointer<ffi.Pointer<knownhosts_entry>>): integer>
   event_remove_session: ffi.Function<function(ffi.Function<nil>, event: event, session: session): integer>
   event_remove_connector: ffi.Function<function(ffi.Function<nil>, event: event, connector: connector): integer>
   event_free: ffi.Function<function(ffi.Function<nil>, event: event): nil>
   session_export_known_hosts_entry: ffi.Function<function(ffi.Function<nil>, session: session, pentry_string: ffi.Pointer<ffi.Pointer<integer>>): integer>
   get_kex_algo: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   get_cipher_in: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   session_update_known_hosts: ffi.Function<function(ffi.Function<nil>, session: session): integer>
   get_hmac_out: ffi.Function<function(ffi.Function<nil>, session: session): ffi.String>
   set_log_level: ffi.Function<function(ffi.Function<nil>, level: integer): integer>
   event_remove_fd: ffi.Function<function(ffi.Function<nil>, event: event, fd: socket_t): integer>
   event_new: ffi.Function<function(ffi.Function<nil>, nil): event>
   getpass: ffi.Function<function(ffi.Function<nil>, prompt: ffi.String, buf: ffi.Pointer<integer>, len: size_t, echo: integer, verify: integer): integer>
   get_log_level: ffi.Function<function(ffi.Function<nil>, nil): integer>
   get_log_userdata: ffi.Function<function(ffi.Function<nil>, nil): ffi.Pointer<nil>>
   set_log_userdata: ffi.Function<function(ffi.Function<nil>, data: ffi.Pointer<nil>): integer>
   vlog: ffi.Function<function(ffi.Function<nil>, verbosity: integer, functio: ffi.String, format: ffi.String, va: ffi.Pointer<va_list>): nil>
   string_to_char: ffi.Function<function(ffi.Function<nil>, str: string): ffi.Pointer<integer>>
   string_new: ffi.Function<function(ffi.Function<nil>, size: size_t): string>
   string_len: ffi.Function<function(ffi.Function<nil>, str: string): size_t>
   string_free: ffi.Function<function(ffi.Function<nil>, str: string): nil>
   string_fill: ffi.Function<function(ffi.Function<nil>, str: string, data: ffi.Pointer<nil>, len: size_t): integer>
   string_copy: ffi.Function<function(ffi.Function<nil>, str: string): string>
   version: ffi.Function<function(ffi.Function<nil>, req_version: integer): ffi.String>
   userauth_kbdint_setanswer: ffi.Function<function(ffi.Function<nil>, session: session, i: integer, answer: ffi.String): integer>
   blocking_flush: ffi.Function<function(ffi.Function<nil>, session: session, timeout: integer): integer>
   userauth_kbdint_getanswer: ffi.Function<function(ffi.Function<nil>, session: session, i: integer): ffi.String>
   free: ffi.Function<function(ffi.Function<nil>, session: session): nil>
   channel_close: ffi.Function<function(ffi.Function<nil>, channel: channel): integer>
   get_hexa: ffi.Function<function(ffi.Function<nil>, what: ffi.Pointer<integer>, len: size_t): ffi.Pointer<integer>>
   get_issue_banner: ffi.Function<function(ffi.Function<nil>, session: session): ffi.Pointer<integer>>
   channel_accept_x11: ffi.Function<function(ffi.Function<nil>, channel: channel, timeout_ms: integer): channel>
   message_channel_request_open_reply_accept: ffi.Function<function(ffi.Function<nil>, msg: message): channel>
   message_channel_request_open_reply_accept_channel: ffi.Function<function(ffi.Function<nil>, msg: message, chan: channel): integer>
   channel_change_pty_size: ffi.Function<function(ffi.Function<nil>, channel: channel, cols: integer, rows: integer): integer>
   message_channel_request_reply_success: ffi.Function<function(ffi.Function<nil>, msg: message): integer>
   get_server_publickey: ffi.Function<function(ffi.Function<nil>, session: session, key: ffi.Pointer<key>): integer>
   __format__: ffi.Function<function(ffi.Function<nil>, __printf__: integer, _3: integer, _4: integer): integer>
   scp_read: ffi.Function<function(ffi.Function<nil>, scp: scp, buffer: ffi.Pointer<nil>, size: size_t): integer>
   message_free: ffi.Function<function(ffi.Function<nil>, msg: message): nil>
   scp_close: ffi.Function<function(ffi.Function<nil>, scp: scp): integer>
   options_parse_config: ffi.Function<function(ffi.Function<nil>, session: session, filename: ffi.String): integer>
   message_get: ffi.Function<function(ffi.Function<nil>, session: session): message>
   message_subtype: ffi.Function<function(ffi.Function<nil>, msg: message): integer>
   message_type: ffi.Function<function(ffi.Function<nil>, msg: message): integer>
   mkdir: ffi.Function<function(ffi.Function<nil>, pathname: ffi.String, mode: mode_t): integer>
   get_fd: ffi.Function<function(ffi.Function<nil>, session: session): socket_t>
   get_error: ffi.Function<function(ffi.Function<nil>, error: ffi.Pointer<nil>): ffi.String>
   new: ffi.Function<function(ffi.Function<nil>, nil): session>
end

local STRIP_PREFIX = "ssh_"

local raw = ffi.load("ssh")

local lib = setmetatable({
   cdef = cdef
}, {
   __index = function(self: {string:any}, key: string): any
      local ckey = STRIP_PREFIX .. key
      local ok, val = pcall(function(): any return raw[ckey] end)
      if ok and not val is nil then
         rawset(self, key, val)
         return val
      end
      local v = raw[key]
      rawset(self, key, v)
      return v
   end,

   __newindex = function(self: {string:any}, key: string, value: any): nil
      local ckey = STRIP_PREFIX .. key
      local ok = pcall(function(): nil raw[ckey] = value end)
      if ok then return end
      raw[key] = value
   end,
})
         

return lib as ssh
