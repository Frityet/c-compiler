package.path = "build/?.lua;build/?/init.lua;src/?.lua;src/?/init.lua;" .. package.path

local parser = require("parser.parser")
local Checker = require("sema.checker")
local lexer = require("lexer.lexer")
local Reporter = require("diag.reporter")

local function run_check(src)
   local rep = Reporter.new()
   local lex = lexer.new_lexer(src, 1)
   local function iter()
      return lexer.next_token(lex)
   end
   local tu = parser.parse(lex.src_ptr, iter, rep)
   local checked = Checker.check(tu, rep)
   return checked, rep
end

describe("sema checker", function()
   it("allows repeated tentative definitions", function()
      local _, rep = run_check("int x; int x;")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("detects conflicting variable types", function()
      local _, rep = run_check("int x; double x;")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM002", rep.diagnostics[1].code)
   end)

   it("detects duplicate variable definitions with initializers", function()
      local _, rep = run_check("int x = 1; int x = 2;")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM003", rep.diagnostics[1].code)
   end)

   it("merges tentative then complete definition", function()
      local checked, rep = run_check("int x; int x = 1;")
      assert.are.equal(0, #rep.diagnostics)
      local sym = checked.globals:lookup("x")
      assert.is_not_nil(sym)
      assert.is_true(sym.is_defined)
      assert.is_false(sym.is_tentative)
   end)

   it("detects duplicate function definitions", function()
      local _, rep = run_check("int f() { return 0; } int f() { return 1; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM003", rep.diagnostics[1].code)
   end)

   it("flags conflicting function declarations", function()
      local _, rep = run_check("int f(); double f();")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM002", rep.diagnostics[1].code)
   end)

   it("completes tag definitions and errors on redefinition", function()
      local checked, rep = run_check("struct S { int a; } s1; struct S { int b; } s2;")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM004", rep.diagnostics[1].code)
      local tag = checked.globals:lookup("S", "tag")
      assert.is_not_nil(tag)
      assert.is_true(tag.is_defined)
   end)

   it("rejects VLA with static storage", function()
      local _, rep = run_check("int n; static int a[*];")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM010", rep.diagnostics[1].code)
   end)

   it("rejects static array parameters without constant bounds", function()
      local _, rep = run_check("void f(int n, int a[static n]);")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM011", rep.diagnostics[1].code)
   end)

   it("allows static array parameters with constant positive bounds", function()
      local _, rep = run_check("void f(int a[static 3]);")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("adjusts array parameters to pointers with no diagnostics", function()
      local checked, rep = run_check("void f(int a[3]);")
      assert.are.equal(0, #rep.diagnostics)
      local func = checked.tu.decls[1]
      assert.are.equal("function", func.type.tag)
      assert.are.equal("pointer", func.type.params[1].type.tag)
   end)

   it("rejects restrict qualifier on non-pointer types", function()
      local _, rep = run_check("void f(restrict int x);")
      assert.is_true(#rep.diagnostics > 0)
   end)

   it("rejects incomplete types in parameters", function()
      local _, rep = run_check("struct S; void f(struct S s);")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM013", rep.diagnostics[1].code)
   end)

   it("allows pointers to incomplete types in parameters", function()
      local _, rep = run_check("struct S; void f(struct S *s);")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("detects use of undeclared identifiers", function()
      local _, rep = run_check("int main() { return y; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM020", rep.diagnostics[1].code)
   end)

   it("rejects assignments to const lvalues", function()
      local _, rep = run_check("int main() { const int x = 1; x = 2; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM016", rep.diagnostics[1].code)
   end)

   it("flags missing return values for non-void functions", function()
      local _, rep = run_check("int f() { return; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM019", rep.diagnostics[1].code)
   end)

   it("rejects returning a value from void functions", function()
      local _, rep = run_check("void f() { return 1; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM019", rep.diagnostics[1].code)
   end)

   it("detects break or continue outside loops/switch", function()
      local _, rep = run_check("void f() { break; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM021", rep.diagnostics[1].code)
   end)

   it("detects duplicate case labels", function()
      local _, rep = run_check("void f() { switch (1) { case 1:; case 1:; } }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM026", rep.diagnostics[1].code)
   end)

   it("errors on calling non-function expressions", function()
      local _, rep = run_check("int x; int main() { x(); }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM028", rep.diagnostics[1].code)
   end)

   it("allows string literals to bind to pointer parameters in calls", function()
      local _, rep = run_check([[int printf(const char *fmt, ...); int main() { printf("%d", 1); }]])
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("requires labels to be declared before use", function()
      local _, rep = run_check("void f() { goto missing; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM022", rep.diagnostics[1].code)
   end)

   it("treats anonymous structs as compatible when structurally equal", function()
      local _, rep = run_check("struct S { int a; }; int main() { struct { int a; } x; struct S y; y = x; }")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("evaluates constant expressions in case labels", function()
      local _, rep = run_check("int f(int x) { switch (x) { case 1 + 2: return 0; } }")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("allows null pointer constant assignments", function()
      local _, rep = run_check("int *p = 0;")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("allows pointer compatibility through void *", function()
      local _, rep = run_check("int *p; int main() { void *v = p; p = v; }")
      assert.are.equal(0, #rep.diagnostics)
   end)

   it("rejects incompatible struct assignments", function()
      local _, rep = run_check("struct A { int a; }; struct B { int a; int b; }; int main() { struct A a; struct B b; a = b; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM030", rep.diagnostics[1].code)
   end)

   it("rejects assigning non-zero integer to pointer", function()
      local _, rep = run_check("int *p; int main() { p = 5; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM030", rep.diagnostics[1].code)
   end)

   it("errors on division by zero with constants", function()
      local _, rep = run_check("int main() { int x = 1 / 0; }")
      assert.are.equal(1, #rep.diagnostics)
      assert.are.equal("SEM042", rep.diagnostics[1].code)
   end)

   it("errors on invalid shift counts", function()
      local _, rep = run_check("int main() { int x = 1 << -1; int y = 1 << 80; }")
      assert.are.equal(2, #rep.diagnostics)
      assert.are.equal("SEM041", rep.diagnostics[1].code)
   end)
end)
