local ffi = require("ffi")
local Lua = require("lua")

local cdef = [[
/* generated by autogen_ffi */

typedef struct FILE FILE;
struct luaL_Stream {
  FILE * f;
  lua_CFunction closef;
};

struct luaL_Reg {
  const char * name;
  lua_CFunction func;
};

typedef struct luaL_Buffer luaL_Buffer;
typedef struct luaL_Reg luaL_Reg;
typedef struct luaL_Stream luaL_Stream;
void luaL_addgsub(luaL_Buffer * b, const char * s, const char * p, const char * r);
void luaL_addlstring(luaL_Buffer * B, const char * s, size_t l);
void luaL_addstring(luaL_Buffer * B, const char * s);
void luaL_addvalue(luaL_Buffer * B);
int luaL_argerror(lua_State * L, int arg, const char * extramsg);
void luaL_buffinit(lua_State * L, luaL_Buffer * B);
char * luaL_buffinitsize(lua_State * L, luaL_Buffer * B, size_t sz);
int luaL_callmeta(lua_State * L, int obj, const char * e);
void luaL_checkany(lua_State * L, int arg);
lua_Integer luaL_checkinteger(lua_State * L, int arg);
const char * luaL_checklstring(lua_State * L, int arg, size_t * l);
lua_Number luaL_checknumber(lua_State * L, int arg);
int luaL_checkoption(lua_State * L, int arg, const char * def, const char * const * lst);
void luaL_checkstack(lua_State * L, int sz, const char * msg);
void luaL_checktype(lua_State * L, int arg, int t);
void * luaL_checkudata(lua_State * L, int ud, const char * tname);
void luaL_checkversion_(lua_State * L, lua_Number ver, size_t sz);
int luaL_error(lua_State * L, const char * fmt, ...);
int luaL_execresult(lua_State * L, int stat);
int luaL_fileresult(lua_State * L, int stat, const char * fname);
int luaL_getmetafield(lua_State * L, int obj, const char * e);
int luaL_getsubtable(lua_State * L, int idx, const char * fname);
const char * luaL_gsub(lua_State * L, const char * s, const char * p, const char * r);
lua_Integer luaL_len(lua_State * L, int idx);
int luaL_loadbufferx(lua_State * L, const char * buff, size_t sz, const char * name, const char * mode);
int luaL_loadfilex(lua_State * L, const char * filename, const char * mode);
int luaL_loadstring(lua_State * L, const char * s);
int luaL_newmetatable(lua_State * L, const char * tname);
lua_State * luaL_newstate(void);
lua_Integer luaL_optinteger(lua_State * L, int arg, lua_Integer def);
const char * luaL_optlstring(lua_State * L, int arg, const char * def, size_t * l);
lua_Number luaL_optnumber(lua_State * L, int arg, lua_Number def);
char * luaL_prepbuffsize(luaL_Buffer * B, size_t sz);
void luaL_pushresult(luaL_Buffer * B);
void luaL_pushresultsize(luaL_Buffer * B, size_t sz);
int luaL_ref(lua_State * L, int t);
void luaL_requiref(lua_State * L, const char * modname, lua_CFunction openf, int glb);
void luaL_setfuncs(lua_State * L, const luaL_Reg * l, int nup);
void luaL_setmetatable(lua_State * L, const char * tname);
void * luaL_testudata(lua_State * L, int ud, const char * tname);
const char * luaL_tolstring(lua_State * L, int idx, size_t * len);
void luaL_traceback(lua_State * L, lua_State * L1, const char * msg, int level);
int luaL_typeerror(lua_State * L, int arg, const char * tname);
void luaL_unref(lua_State * L, int t, int ref);
void luaL_where(lua_State * L, int lvl);
]]

ffi.cdef(cdef)

local record lauxlib
   record Stream is ffi.CData where ffi.istype("struct luaL_Stream", self)

      f: ffi.Pointer<FILE>

      closef: Lua.CFunction

   end

   record Reg is ffi.CData where ffi.istype("struct luaL_Reg", self)

      name: ffi.String

      func: Lua.CFunction

   end
   record Buffer is ffi.CData where ffi.istype("struct luaL_Buffer", self) end

   argerror: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, extramsg: ffi.String): integer>
   typeerror: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, tname: ffi.String): integer>
   requiref: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, modname: ffi.String, openf: Lua.CFunction, glb: integer): nil>
   checklstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, l: ffi.Pointer<Lua.size_t>): ffi.String>
   optlstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, def: ffi.String, l: ffi.Pointer<Lua.size_t>): ffi.String>
   checknumber: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer): Lua.Number>
   optnumber: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, def: Lua.Number): Lua.Number>
   checkinteger: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer): Lua.Integer>
   optinteger: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, def: Lua.Integer): Lua.Integer>
   checkstack: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, sz: integer, msg: ffi.String): nil>
   checktype: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, t: integer): nil>
   checkany: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer): nil>
   unref: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, t: integer, ref: integer): nil>
   loadfilex: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, filename: ffi.String, mode: ffi.String): integer>
   testudata: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, ud: integer, tname: ffi.String): ffi.Pointer<nil>>
   checkudata: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, ud: integer, tname: ffi.String): ffi.Pointer<nil>>
   where: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, lvl: integer): nil>
   error: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, fmt: ffi.String, ...: any): integer>
   checkversion_: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, ver: Lua.Number, sz: Lua.size_t): nil>
   prepbuffsize: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>, sz: Lua.size_t): ffi.Pointer<integer>>
   checkoption: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, arg: integer, def: ffi.String, lst: ffi.Pointer<ffi.String>): integer>
   loadbufferx: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, buff: ffi.String, sz: Lua.size_t, name: ffi.String, mode: ffi.String): integer>
   buffinitsize: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, B: ffi.Pointer<Buffer>, sz: Lua.size_t): ffi.Pointer<integer>>
   newmetatable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, tname: ffi.String): integer>
   loadstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, s: ffi.String): integer>
   pushresult: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>): nil>
   addvalue: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>): nil>
   newstate: ffi.Function<function(ffi.Function<nil>): ffi.Pointer<Lua.State>>
   callmeta: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, obj: integer, e: ffi.String): integer>
   addlstring: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>, s: ffi.String, l: Lua.size_t): nil>
   len: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, idx: integer): Lua.Integer>
   addgsub: ffi.Function<function(ffi.Function<nil>, b: ffi.Pointer<Buffer>, s: ffi.String, p: ffi.String, r: ffi.String): nil>
   buffinit: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, B: ffi.Pointer<Buffer>): nil>
   traceback: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, L1: ffi.Pointer<Lua.State>, msg: ffi.String, level: integer): nil>
   getmetafield: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, obj: integer, e: ffi.String): integer>
   execresult: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, stat: integer): integer>
   setmetatable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, tname: ffi.String): nil>
   fileresult: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, stat: integer, fname: ffi.String): integer>
   gsub: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, s: ffi.String, p: ffi.String, r: ffi.String): ffi.String>
   addstring: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>, s: ffi.String): nil>
   setfuncs: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, l: ffi.Pointer<Reg>, nup: integer): nil>
   ref: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, t: integer): integer>
   pushresultsize: ffi.Function<function(ffi.Function<nil>, B: ffi.Pointer<Buffer>, sz: Lua.size_t): nil>
   getsubtable: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, idx: integer, fname: ffi.String): integer>
   tolstring: ffi.Function<function(ffi.Function<nil>, L: ffi.Pointer<Lua.State>, idx: integer, len: ffi.Pointer<Lua.size_t>): ffi.String>
end

local STRIP_PREFIX = "luaL_"

local raw = ffi.load("lua")

local lib = setmetatable({
   cdef = cdef
}, {
   __index = function(self: {string:any}, key: string): any
      local ckey = STRIP_PREFIX .. key
      local ok, val = pcall(function(): any return raw[ckey] end)
      if ok and not val is nil then
         rawset(self, key, val)
         return val
      end
      local v = raw[key]
      rawset(self, key, v)
      return v
   end,

   __newindex = function(self: {string:any}, key: string, value: any): nil
      local ckey = STRIP_PREFIX .. key
      local ok = pcall(function(): nil raw[ckey] = value end)
      if ok then return end
      raw[key] = value
   end,
})
         

return lib as lauxlib
