local ffi = require("ffi")
local Lua = require("lua")

local cdef = [[
/* generated by autogen_ffi */
struct luaL_Reg {
  const char * name;
  lua_CFunction func;
};

struct luaL_Stream {
  FILE * f;
  lua_CFunction closef;
};

typedef struct luaL_Buffer luaL_Buffer;
typedef struct luaL_Reg luaL_Reg;
typedef struct luaL_Stream luaL_Stream;
void luaL_addgsub(luaL_Buffer * b, const char * s, const char * p, const char * r);
void luaL_addlstring(luaL_Buffer * B, const char * s, size_t l);
void luaL_addstring(luaL_Buffer * B, const char * s);
void luaL_addvalue(luaL_Buffer * B);
int luaL_argerror(lua_State * L, int arg, const char * extramsg);
void luaL_buffinit(lua_State * L, luaL_Buffer * B);
int luaL_callmeta(lua_State * L, int obj, const char * e);
void luaL_checkany(lua_State * L, int arg);
lua_Integer luaL_checkinteger(lua_State * L, int arg);
lua_Number luaL_checknumber(lua_State * L, int arg);
int luaL_checkoption(lua_State * L, int arg, const char * def, const char * const * lst);
void luaL_checkstack(lua_State * L, int sz, const char * msg);
void luaL_checktype(lua_State * L, int arg, int t);
void luaL_checkversion_(lua_State * L, lua_Number ver, size_t sz);
int luaL_error(lua_State * L, const char * fmt, ...);
int luaL_execresult(lua_State * L, int stat);
int luaL_fileresult(lua_State * L, int stat, const char * fname);
int luaL_getmetafield(lua_State * L, int obj, const char * e);
int luaL_getsubtable(lua_State * L, int idx, const char * fname);
lua_Integer luaL_len(lua_State * L, int idx);
int luaL_loadbufferx(lua_State * L, const char * buff, size_t sz, const char * name, const char * mode);
int luaL_loadfilex(lua_State * L, const char * filename, const char * mode);
int luaL_loadstring(lua_State * L, const char * s);
int luaL_newmetatable(lua_State * L, const char * tname);
lua_Integer luaL_optinteger(lua_State * L, int arg, lua_Integer def);
lua_Number luaL_optnumber(lua_State * L, int arg, lua_Number def);
void luaL_pushresult(luaL_Buffer * B);
void luaL_pushresultsize(luaL_Buffer * B, size_t sz);
int luaL_ref(lua_State * L, int t);
void luaL_requiref(lua_State * L, const char * modname, lua_CFunction openf, int glb);
void luaL_setfuncs(lua_State * L, const luaL_Reg * l, int nup);
void luaL_setmetatable(lua_State * L, const char * tname);
void luaL_traceback(lua_State * L, lua_State * L1, const char * msg, int level);
int luaL_typeerror(lua_State * L, int arg, const char * tname);
void luaL_unref(lua_State * L, int t, int ref);
void luaL_where(lua_State * L, int lvl);
]]

ffi.cdef(cdef)

local record lauxlib
   record Reg is ffi.CData where ffi.istype("struct luaL_Reg", self)

      name: ffi.Pointer<integer>

      func: Lua.CFunction

   end

   record Stream is ffi.CData where ffi.istype("struct luaL_Stream", self)

      f: ffi.Pointer<FILE>

      closef: Lua.CFunction

   end

   record Buffer is ffi.CData where ffi.istype("struct luaL_Buffer", self) end

   unref: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, t: integer, ref: integer): nil>
   loadfilex: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, filename: ffi.Pointer<integer>, mode: ffi.Pointer<integer>): integer>
   buffinit: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, B: ffi.Pointer<Buffer>): nil>
   requiref: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, modname: ffi.Pointer<integer>, openf: Lua.CFunction, glb: integer): nil>
   argerror: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, extramsg: ffi.Pointer<integer>): integer>
   addlstring: ffi.Function<function(ffi.NilFunc, B: ffi.Pointer<Buffer>, s: ffi.Pointer<integer>, l: Lua.size_t): nil>
   typeerror: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, tname: ffi.Pointer<integer>): integer>
   addvalue: ffi.Function<function(ffi.NilFunc, B: ffi.Pointer<Buffer>): nil>
   pushresult: ffi.Function<function(ffi.NilFunc, B: ffi.Pointer<Buffer>): nil>
   pushresultsize: ffi.Function<function(ffi.NilFunc, B: ffi.Pointer<Buffer>, sz: Lua.size_t): nil>
   loadbufferx: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, buff: ffi.Pointer<integer>, sz: Lua.size_t, name: ffi.Pointer<integer>, mode: ffi.Pointer<integer>): integer>
   getmetafield: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, obj: integer, e: ffi.Pointer<integer>): integer>
   loadstring: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, s: ffi.Pointer<integer>): integer>
   checknumber: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer): Lua.Number>
   optnumber: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, def: Lua.Number): Lua.Number>
   checkinteger: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer): Lua.Integer>
   optinteger: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, def: Lua.Integer): Lua.Integer>
   checkstack: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, sz: integer, msg: ffi.Pointer<integer>): nil>
   len: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, idx: integer): Lua.Integer>
   addgsub: ffi.Function<function(ffi.NilFunc, b: ffi.Pointer<Buffer>, s: ffi.Pointer<integer>, p: ffi.Pointer<integer>, r: ffi.Pointer<integer>): nil>
   checktype: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, t: integer): nil>
   checkany: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer): nil>
   newmetatable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, tname: ffi.Pointer<integer>): integer>
   setmetatable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, tname: ffi.Pointer<integer>): nil>
   where: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, lvl: integer): nil>
   setfuncs: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, l: ffi.Pointer<Reg>, nup: integer): nil>
   error: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, fmt: ffi.Pointer<integer>, ...: any): integer>
   checkoption: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, arg: integer, def: ffi.Pointer<integer>, lst: ffi.Pointer<ffi.Pointer<integer>>): integer>
   fileresult: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, stat: integer, fname: ffi.Pointer<integer>): integer>
   execresult: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, stat: integer): integer>
   addstring: ffi.Function<function(ffi.NilFunc, B: ffi.Pointer<Buffer>, s: ffi.Pointer<integer>): nil>
   callmeta: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, obj: integer, e: ffi.Pointer<integer>): integer>
   checkversion_: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, ver: Lua.Number, sz: Lua.size_t): nil>
   getsubtable: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, idx: integer, fname: ffi.Pointer<integer>): integer>
   traceback: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, L1: ffi.Pointer<Lua.State>, msg: ffi.Pointer<integer>, level: integer): nil>
   ref: ffi.Function<function(ffi.NilFunc, L: ffi.Pointer<Lua.State>, t: integer): integer>
end

local STRIP_PREFIX = "luaL_"

local lauxlib: lauxlib = ffi.load("lua") as lauxlib

getmetatable(lauxlib).__index = function(self: {string:any}, key: string): any
   local ckey = STRIP_PREFIX .. key
   local val = rawget(self, ckey)
   if not val is nil then return val end
   val = rawget(self, key)
   if not val is nil then return val end
   error("attempt to access undefined member '" .. key .. "'")
end

return lauxlib
